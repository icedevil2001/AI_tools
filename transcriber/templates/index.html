<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio/Video Transcription</title>
    
    <!-- Add the Marked library for Markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="/static/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="/static/css/custom.css">
    
    <!-- Custom CSS -->
    <link rel="stylesheet" href="/static/css/main.css">
    
    <!-- Favicon -->
    <link rel="icon" href="/static/images/favicon.ico" type="image/x-icon">
    
    <!-- Custom JavaScript -->
    <script src="/static/js/main.js" defer></script>
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <span class="sidebar-title">Transcriptions</span>
                <div class="sidebar-toggle" id="sidebarToggle">
                    <i class="fas fa-chevron-left"></i>
                </div>
            </div>
            <div class="sidebar-content">
                <div class="new-transcript" id="newTranscriptBtn">
                    <i class="fas fa-plus"></i>
                    <span>New Transcription</span>
                </div>
                <ul class="transcript-list" id="transcriptList">
                    <!-- Transcripts will be populated here -->
                    <!-- Example item -->
                    <li class="transcript-list-item active">
                        <div class="transcript-list-item-icon">
                            <i class="fas fa-file-alt"></i>
                        </div>
                        <div class="transcript-list-item-text">Loading transcripts...</div>
                    </li>
                </ul>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content" id="mainContent">
            <div class="main-header">
                <input type="text" class="editable-title" id="transcriptTitle" placeholder="New Transcription" readonly>
            </div>
            
            <div class="container">
                <div class="card">
                    <div class="card-header">
                        <h2><i class="fas fa-upload"></i> Upload File</h2>
                    </div>
                    
                    <div id="uploadArea" class="upload-area">
                        <i class="fas fa-cloud-upload-alt upload-icon"></i>
                        <h3>Drag & Drop or Click to Upload</h3>
                        <p>Supported formats: MP3, M4A, WAV, MP4</p>
                        
                        <div class="file-input-container">
                            <button class="btn">
                                <i class="fas fa-file-audio"></i> Choose File
                            </button>
                            <input type="file" id="fileInput" class="file-input" accept=".mp3,.mp4,.wav,.m4a">
                        </div>
                        
                        <form id="uploadForm" style="display:none;">
                            <!-- Form is hidden but still functional -->
                        </form>
                    </div>
                    
                    <div class="file-info">
                        <i class="fas fa-info-circle"></i>
                        <span>Maximum file size: 32MB</span>
                    </div>
                    
                    <div class="audio-container">
                        <div id="audioPlayer" class="custom-audio-player">
                            <audio class="audio-player" controls>
                                Your browser does not support the audio element.
                            </audio>
                        </div>
                    </div>
                </div>
                
                <div id="loading" class="loading">
                    <div class="loading-text">
                        <span>Processing your audio</span>
                        <div class="dot-pulse"></div>
                    </div>
                    <p>This may take a while for longer files</p>
                </div>
                
                <div class="transcript-container">
                    <!-- Transcript section -->
                    <div class="card" id="transcriptSection">
                        <div class="card-header">
                            <h2><i class="fas fa-file-alt"></i> Transcript</h2>
                            <div class="section-actions">
                                <button class="action-btn tooltip" id="copyTranscriptBtn" title="Copy transcript">
                                    <i class="fas fa-copy"></i>
                                    <span class="tooltip-text">Copied!</span>
                                </button>
                                <button class="action-btn" id="collapseTranscriptBtn" title="Toggle transcript">
                                    <i class="fas fa-chevron-up"></i>
                                </button>
                            </div>
                        </div>
                        
                        <div id="transcript" class="transcript-content">
                            <em>No transcript yet. Upload a file to begin.</em>
                        </div>
                        
                        <div class="buttons-row">
                            <button id="summarizeBtn" class="btn">
                                <i class="fas fa-chart-bar"></i> Generate Summary
                            </button>
                            <button id="askQuestionsBtn" class="btn btn-outline">
                                <i class="fas fa-question-circle"></i> Ask Questions
                            </button>
                        </div>
                    </div>
                    
                    <!-- Summary section -->
                    <div class="card" id="summarySection">
                        <div class="card-header">
                            <h2><i class="fas fa-chart-pie"></i> Summary</h2>
                            <div class="section-actions">
                                <button class="action-btn tooltip" id="copySummaryBtn" title="Copy summary">
                                    <i class="fas fa-copy"></i>
                                    <span class="tooltip-text">Copied!</span>
                                </button>
                            </div>
                        </div>
                        
                        <div id="summaryLoading" style="display:none;">
                            <div class="loading-text">
                                <span>Generating summary</span>
                                <div class="loading-spinner"></div>
                            </div>
                        </div>
                        
                        <div id="summary" class="summary-content">
                            <em>Generate a summary after transcribing your audio.</em>
                        </div>
                    </div>
                    
                    <!-- Chat/Q&A section -->
                    <div class="card" id="chatSection">
                        <div class="card-header">
                            <h2><i class="fas fa-comments"></i> Ask Questions</h2>
                        </div>
                        
                        <div class="chat-container">
                            <div id="chatMessages" class="chat-messages">
                                <div class="message ai-message">
                                    Ask me questions about the transcript!
                                </div>
                            </div>
                            
                            <div class="chat-input-container">
                                <input type="text" id="questionInput" class="chat-input" placeholder="Ask a question about the transcript...">
                                <button id="sendQuestionBtn" class="chat-send-btn">
                                    <i class="fas fa-paper-plane"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Mobile Menu Toggle Button -->
    <button class="mobile-menu-toggle" id="mobileMenuToggle">
        <i class="fas fa-bars"></i>
    </button>

    <!-- Modals for Transcript Management -->
    <div class="modal-backdrop" id="renameModal">
        <div class="modal">
            <div class="modal-header">
                <h3>Rename Transcript</h3>
                <button class="modal-close" data-dismiss="modal">×</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label" for="newTranscriptName">New Name</label>
                    <input type="text" class="form-control" id="newTranscriptName" placeholder="Enter new transcript name">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-outline" data-dismiss="modal">Cancel</button>
                <button class="btn" id="saveRenameBtn">Save</button>
            </div>
        </div>
    </div>

    <div class="modal-backdrop" id="deleteModal">
        <div class="modal">
            <div class="modal-header">
                <h3>Delete Transcript</h3>
                <button class="modal-close" data-dismiss="modal">×</button>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to delete this transcript? This action cannot be undone.</p>
                <p><strong>Transcript: </strong><span id="deleteTranscriptName"></span></p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-outline" data-dismiss="modal">Cancel</button>
                <button class="btn" id="confirmDeleteBtn" style="background-color: var(--danger);">Delete</button>
            </div>
        </div>
    </div>

    <!-- Dashboard Widgets (moved outside of main content) -->
    <!-- <div class="dashboard-widgets"> -->
        <!-- Cost Tracker -->
        <!--
        <div class="widget" id="costTracker">
            <div class="widget-header">
                <span><i class="fas fa-coins"></i> API Usage Costs</span>
                <span class="minimize-btn" id="minimizeBtn">−</span>
            </div>
            <div class="widget-body" id="costContent">
                <div class="cost-detail">
                    <span>Total Tokens:</span>
                    <span id="totalTokens">0</span>
                </div>
                <div class="cost-detail">
                    <span>Transcription:</span>
                    <span id="transcriptionRequests">0 requests</span>
                </div>
                <div class="cost-detail">
                    <span>Summaries:</span>
                    <span id="summaryRequests">0 requests</span>
                </div>
                <div class="cost-detail">
                    <span>Q&A:</span>
                    <span id="qaRequests">0 requests</span>
                </div>
                <div class="cost-total">
                    <span>Total Cost:</span>
                    <span id="totalCost">$0.00</span>
                </div>
            </div>
        </div>
        -->

        <!-- Rate Limit Indicator -->
        <!--
        <div class="widget" id="rateLimitIndicator">
            <div class="widget-header">
                <span><i class="fas fa-tachometer-alt"></i> API Rate Limits</span>
                <span class="minimize-btn" id="minimizeRateBtn">−</span>
            </div>
            <div class="widget-body" id="rateLimitContent">
                <div id="transcriptionRate">
                    <div class="rate-status">
                        <div class="rate-status-light status-green" id="transcriptionLight"></div>
                        <span>Transcription</span>
                    </div>
                    <div class="rate-bar-container">
                        <div class="rate-bar" id="transcriptionBar" style="width: 0%"></div>
                    </div>
                    <div class="rate-labels">
                        <span>0</span>
                        <span id="transcriptionLimit">10/min</span>
                    </div>
                </div>
                
                <div id="summaryRate">
                    <div class="rate-status">
                        <div class="rate-status-light status-green" id="summaryLight"></div>
                        <span>Summary</span>
                    </div>
                    <div class="rate-bar-container">
                        <div class="rate-bar" id="summaryBar" style="width: 0%"></div>
                    </div>
                    <div class="rate-labels">
                        <span>0</span>
                        <span id="summaryLimit">10/min</span>
                    </div>
                </div>
                
                <div id="qaRate">
                    <div class="rate-status">
                        <div class="rate-status-light status-green" id="qaLight"></div>
                        <span>Q&A</span>
                    </div>
                    <div class="rate-bar-container">
                        <div class="rate-bar" id="qaBar" style="width: 0%"></div>
                    </div>
                    <div class="rate-labels">
                        <span>0</span>
                        <span id="qaLimit">10/min</span>
                    </div>
                </div>
                
                <div class="cooldown-message" id="cooldownMessage"></div>
            </div>
        </div>
        -->
    <!-- </div> -->
    
    <!-- Debug Panel (will be hidden in production) -->
    <div class="debug-panel"></div>
        <h3><i class="fas fa-bug"></i> Debug Information</h3>
        <div id="debugInfo">Status: Waiting for user action</div>
    </div>

    <script>
        // Debug function
        function debug(message) {
            console.log(message);
            document.getElementById('debugInfo').textContent = "Status: " + message;
        }
        
        // Grab all DOM elements
        const fileInput = document.getElementById('fileInput');
        const uploadForm = document.getElementById('uploadForm');
        const uploadArea = document.getElementById('uploadArea');
        const audioPlayerContainer = document.getElementById('audioPlayer');
        const audioPlayer = audioPlayerContainer.querySelector('audio');
        const loading = document.getElementById('loading');
        const transcript = document.getElementById('transcript');
        const summaryBtn = document.getElementById('summarizeBtn');
        const askQuestionsBtn = document.getElementById('askQuestionsBtn');
        const summarySection = document.getElementById('summarySection');
        const summaryContent = document.getElementById('summary');
        const summaryLoading = document.getElementById('summaryLoading');
        const chatSection = document.getElementById('chatSection');
        const chatMessages = document.getElementById('chatMessages');
        const questionInput = document.getElementById('questionInput');
        const sendQuestionBtn = document.getElementById('sendQuestionBtn');
        
        // Sidebar and new UI elements
        const sidebar = document.getElementById('sidebar');
        const sidebarToggle = document.getElementById('sidebarToggle');
        const mainContent = document.getElementById('mainContent');
        const transcriptList = document.getElementById('transcriptList');
        const newTranscriptBtn = document.getElementById('newTranscriptBtn');
        const mobileMenuToggle = document.getElementById('mobileMenuToggle');
        const transcriptTitle = document.getElementById('transcriptTitle');

        // Modal elements
        const renameModal = document.getElementById('renameModal');
        const deleteModal = document.getElementById('deleteModal');
        const newTranscriptName = document.getElementById('newTranscriptName');
        const deleteTranscriptName = document.getElementById('deleteTranscriptName');
        const saveRenameBtn = document.getElementById('saveRenameBtn');
        const confirmDeleteBtn = document.getElementById('confirmDeleteBtn');
        
        // Global variables for transcript management
        let currentTranscriptId = null;
        let userTranscripts = [];
        let activeTranscriptItem = null;
        let pendingTitleUpdate = null;
        
        debug("Page loaded successfully");
        
        // Store session info
        let currentSessionId = null;
        let currentTranscript = null;

        // Initialize the UI - Execute immediately to avoid waiting for DOMContentLoaded
        function initializeUI() {
            debug("Initializing UI");
            
            // Setup sidebar toggle
            sidebarToggle.addEventListener('click', toggleSidebar);
            if (mobileMenuToggle) {
                mobileMenuToggle.addEventListener('click', toggleMobileSidebar);
            }
            
            // Close modals when clicking outside or on close button
            document.querySelectorAll('.modal-backdrop').forEach(modal => {
                modal.addEventListener('click', function(event) {
                    if (event.target === modal) {
                        closeModals();
                    }
                });
            });
            
            document.querySelectorAll('[data-dismiss="modal"]').forEach(btn => {
                btn.addEventListener('click', closeModals);
            });
            
            // Make sure the widget bodies are visible (not minimized) on page load
            if (costContent) costContent.classList.remove('minimized');
            if (rateLimitContent) rateLimitContent.classList.remove('minimized');
            
            // Setup editable title
            setupEditableTitle();
            
            // Load user transcripts
            loadUserTranscripts();
            
            // Setup modal actions
            if (saveRenameBtn) saveRenameBtn.addEventListener('click', handleRename);
            if (confirmDeleteBtn) confirmDeleteBtn.addEventListener('click', handleDelete);
            
            // New transcript button action
            if (newTranscriptBtn) {
                newTranscriptBtn.addEventListener('click', function() {
                    clearTranscript();
                    setActiveTranscript(null);
                });
            }
        }
        
        // Toggle sidebar function - Fixed to use proper CSS variables
        function toggleSidebar() {
            sidebar.classList.toggle('collapsed');
            
            // Adjust main content margin - Fixed computation with CSS variables
            if (sidebar.classList.contains('collapsed')) {
                mainContent.style.marginLeft = '60px'; // Use explicit pixel value instead of CSS var
            } else {
                mainContent.style.marginLeft = '280px'; // Use explicit pixel value instead of CSS var
            }
        }
        
        // Toggle mobile sidebar
        function toggleMobileSidebar() {
            sidebar.classList.toggle('show');
        }
        
        // Drag and drop functionality
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, preventDefaults, false);
        });
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        ['dragenter', 'dragover'].forEach(eventName => {
            uploadArea.addEventListener(eventName, highlight, false);
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, unhighlight, false);
        });
        
        function highlight() {
            uploadArea.classList.add('dragover');
        }
        
        function unhighlight() {
            uploadArea.classList.remove('dragover');
        }
        
        uploadArea.addEventListener('drop', handleDrop, false);
        
        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            
            if (files.length) {
                fileInput.files = files;
                handleFileSelect();
            }
        }
        
        // Connect file input to the hidden form
        fileInput.addEventListener('change', handleFileSelect);
        
        function handleFileSelect() {
            const file = fileInput.files[0];
            if (file) {
                const fileURL = URL.createObjectURL(file);
                debug(`File selected: ${file.name} (${file.type})`);
                
                // MP4 files need to be handled differently
                if (file.name.toLowerCase().endsWith('.mp4')) {
                    audioPlayerContainer.style.display = 'none';
                    debug("MP4 file detected - audio player hidden");
                } else {
                    audioPlayer.src = fileURL;
                    audioPlayerContainer.style.display = 'block';
                    debug("Audio file loaded into player");
                }
                
                // Automatically submit the form when file is selected
                submitTranscriptionForm();
            }
        }

        // Handle transcription form submission - Fixed to properly create FormData
        function submitTranscriptionForm() {
            debug("Beginning transcription process");
            
            // Clear any existing transcript data
            clearTranscript();
            setActiveTranscript(null);
            
            const formData = new FormData();
            
            // Make sure we have a file selected
            if (!fileInput.files || !fileInput.files[0]) {
                debug("No file selected");
                return;
            }
            
            formData.append('file', fileInput.files[0]);

            loading.style.display = 'block';
            transcript.innerHTML = '<em>Transcribing your audio...</em>';

            fetch('/transcribe', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                debug("Response received from server");
                
                if (data.error) {
                    if (data.error.includes('Rate limit')) {
                        transcript.innerHTML = `<p style="color: var(--danger);">Rate limit reached. Please wait a moment and try again.</p>`;
                        debug(`Rate limit error: ${data.error}`);
                        updateRateLimits(); // Update rate limits immediately
                    } else {
                        transcript.textContent = `Error: ${data.error}`;
                        debug(`Error occurred: ${data.error}`);
                    }
                } else {
                    // Store session data
                    currentSessionId = data.sessionId;
                    currentTranscript = data.transcript;
                    currentTranscriptId = data.sessionId;
                    debug(`Transcript received, session ID: ${currentSessionId}`);
                    
                    // Format the transcript with speaker highlighting
                    const formattedText = data.transcript.replace(
                        /(Speaker \d+|[A-Za-z]+ [A-Za-z]+):/g, 
                        '<span class="speaker">$1:</span>'
                    );
                    transcript.innerHTML = formattedText || "No transcript content returned";
                    
                    // Update title
                    const generatedTitle = generateTitleFromTranscript(data.transcript);
                    transcriptTitle.value = generatedTitle;
                    transcriptTitle.dataset.originalValue = generatedTitle;
                    
                    // If there's a temporary file URL for playback
                    if (data.audioUrl) {
                        audioPlayer.src = data.audioUrl;
                        audioPlayerContainer.style.display = 'block';
                        debug(`Audio URL loaded: ${data.audioUrl}`);
                    }
                    
                    // Save title with transcript
                    updateTranscriptTitle(data.sessionId, generatedTitle)
                        .then(() => {
                            // Refresh transcript list
                            setTimeout(loadUserTranscripts, 500);
                        })
                        .catch(error => {
                            debug(`Error saving transcript title: ${error}`);
                        });
                    
                    // Update cost information after transcription
                    setTimeout(updateCostInfo, 500);
                }
                
                // Update rate limits after any API call
                setTimeout(updateRateLimits, 500);
            })
            .catch(error => {
                transcript.textContent = `Error: ${error.message}`;
                debug(`Fetch error: ${error.message}`);
            })
            .finally(() => {
                loading.style.display = 'none';
            });
        }

        // ...existing code for summarization, Q&A, etc...
        
        // Close all modals
        function closeModals() {
            if (renameModal) renameModal.classList.remove('show');
            if (deleteModal) deleteModal.classList.remove('show');
        }
        
        // Open rename modal
        function openRenameModal(transcriptId, currentName) {
            if (!newTranscriptName) return;
            newTranscriptName.value = currentName || '';
            pendingTitleUpdate = { id: transcriptId, currentName: currentName };
            renameModal.classList.add('show');
            setTimeout(() => newTranscriptName.focus(), 100);
        }
        
        // Open delete modal
        function openDeleteModal(transcriptId, name) {
            if (!deleteTranscriptName) return;
            deleteTranscriptName.textContent = name || 'Unnamed Transcript';
            pendingTitleUpdate = { id: transcriptId, currentName: name };
            deleteModal.classList.add('show');
        }
        
        // Handle rename action
        function handleRename() {
            if (!pendingTitleUpdate || !pendingTitleUpdate.id) return;
            
            const newName = newTranscriptName.value.trim();
            if (!newName) return;
            
            // Call API to update transcript title
            updateTranscriptTitle(pendingTitleUpdate.id, newName)
                .then(() => {
                    // Update UI
                    if (pendingTitleUpdate.id === currentTranscriptId) {
                        transcriptTitle.value = newName;
                    }
                    
                    // Update sidebar list
                    loadUserTranscripts();
                    
                    // Close modal
                    closeModals();
                    pendingTitleUpdate = null;
                })
                .catch(error => {
                    debug(`Error renaming transcript: ${error.message}`);
                });
        }
        
        // Handle delete action
        function handleDelete() {
            if (!pendingTitleUpdate || !pendingTitleUpdate.id) return;
            
            // Call API to delete transcript
            deleteTranscript(pendingTitleUpdate.id)
                .then(() => {
                    // Check if we deleted the current transcript
                    if (pendingTitleUpdate.id === currentTranscriptId) {
                        clearTranscript();
                    }
                    
                    // Update sidebar list
                    loadUserTranscripts();
                    
                    // Close modal
                    closeModals();
                    pendingTitleUpdate = null;
                })
                .catch(error => {
                    debug(`Error deleting transcript: ${error.message}`);
                });
        }
        
        // Setup editable title
        function setupEditableTitle() {
            if (!transcriptTitle) return;
            
            // Make it editable on double click
            transcriptTitle.addEventListener('dblclick', function() {
                if (!currentTranscriptId) return; // Can't edit if no current transcript
                
                this.readOnly = false;
                this.focus();
            });
            
            // Save on blur or Enter key
            transcriptTitle.addEventListener('blur', saveTitle);
            transcriptTitle.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    this.blur();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    this.value = this.dataset.originalValue || '';
                    this.readOnly = true;
                }
            });
        }
        
        // Save title when edited
        function saveTitle() {
            const newTitle = this.value.trim();
            
            // Reset state
            this.readOnly = true;
            
            if (!currentTranscriptId || !newTitle || newTitle === this.dataset.originalValue) {
                return; // No changes or no current transcript
            }
            
            // Update title in database
            updateTranscriptTitle(currentTranscriptId, newTitle)
                .then(() => {
                    // Update UI
                    this.dataset.originalValue = newTitle;
                    
                    // Refresh transcript list
                    loadUserTranscripts();
                })
                .catch(error => {
                    debug(`Error saving title: ${error.message}`);
                    // Revert to original value on error
                    this.value = this.dataset.originalValue || '';
                });
        }
        
        // Load user transcripts from the server
        function loadUserTranscripts() {
            fetch('/api/transcripts')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to load transcripts');
                    }
                    return response.json();
                })
                .then(data => {
                    userTranscripts = data.transcripts || [];
                    renderTranscriptList();
                })
                .catch(error => {
                    debug(`Error loading transcripts: ${error.message}`);
                    if (transcriptList) {
                        transcriptList.innerHTML = `
                            <li class="transcript-list-item">
                                <div class="transcript-list-item-icon">
                                    <i class="fas fa-exclamation-circle" style="color: var(--danger);"></i>
                                </div>
                                <div class="transcript-list-item-text">Error loading transcripts</div>
                            </li>
                        `;
                    }
                });
        }

        // Generate a title from transcript content
        function generateTitleFromTranscript(transcript) {
            if (!transcript) return 'Untitled Transcript';
            
            // Get first 50 chars from transcript
            let firstLine = transcript.split('\n')[0] || '';
            
            // Remove speaker labels
            firstLine = firstLine.replace(/^(Speaker \d+|[A-Za-z]+ [A-Za-z]+):\s*/i, '');
            
            // Trim to reasonable length
            if (firstLine.length > 40) {
                firstLine = firstLine.substring(0, 40) + '...';
            }
            
            return firstLine || 'Untitled Transcript';
        }

        // API call to update transcript title
        async function updateTranscriptTitle(transcriptId, newTitle) {
            return fetch(`/api/transcript/${transcriptId}/title`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ title: newTitle })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Failed to update transcript title');
                }
                return response.json();
            });
        }
        
        // API call to delete transcript
        async function deleteTranscript(transcriptId) {
            return fetch(`/api/transcript/${transcriptId}`, {
                method: 'DELETE'
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Failed to delete transcript');
                }
                return response.json();
            });
        }

        // Run initialization immediately
        initializeUI();
    </script>
    <script>
    // ...existing code...

    // Handle transcription form submission - Fixed to properly create FormData
    function submitTranscriptionForm() {
        debug("Beginning transcription process");
        
        const formData = new FormData();
        
        // Make sure we have a file selected
        if (!fileInput.files || !fileInput.files[0]) {
            debug("No file selected");
            return;
        }
        
        formData.append('file', fileInput.files[0]);

        loading.style.display = 'block';
        transcript.innerHTML = '<em>Transcribing your audio...</em>';

        fetch('/transcribe', {
            method: 'POST',
            body: formData
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            debug("Response received from server");
            
            if (data.error) {
                if (data.error.includes('Rate limit')) {
                    transcript.innerHTML = `<p style="color: var(--danger);">Rate limit reached. Please wait a moment and try again.</p>`;
                    debug(`Rate limit error: ${data.error}`);
                    updateRateLimits(); // Update rate limits immediately
                } else {
                    transcript.textContent = `Error: ${data.error}`;
                    debug(`Error occurred: ${data.error}`);
                }
            } else {
                // Store session data
                currentSessionId = data.sessionId;
                currentTranscript = data.transcript;
                currentTranscriptId = data.sessionId;
                debug(`Transcript received, session ID: ${currentSessionId}`);
                
                // Format the transcript with speaker highlighting
                const formattedText = data.transcript.replace(
                    /(Speaker \d+|[A-Za-z]+ [A-Za-z]+):/g, 
                    '<span class="speaker">$1:</span>'
                );
                transcript.innerHTML = formattedText || "No transcript content returned";
                
                // Update title
                const generatedTitle = generateTitleFromTranscript(data.transcript);
                transcriptTitle.value = generatedTitle;
                transcriptTitle.dataset.originalValue = generatedTitle;
                
                // If there's a temporary file URL for playback
                if (data.audioUrl) {
                    audioPlayer.src = data.audioUrl;
                    audioPlayerContainer.style.display = 'block';
                    debug(`Audio URL loaded: ${data.audioUrl}`);
                }
                
                // Save title with transcript
                updateTranscriptTitle(data.sessionId, generatedTitle)
                    .then(() => {
                        // Refresh transcript list
                        setTimeout(loadUserTranscripts, 500);
                    })
                    .catch(error => {
                        debug(`Error saving transcript title: ${error}`);
                    });
                
                // Update cost information after transcription
                setTimeout(updateCostInfo, 500);
            }
            
            // Update rate limits after any API call
            setTimeout(updateRateLimits, 500);
        })
        .catch(error => {
            transcript.textContent = `Error: ${error.message}`;
            debug(`Fetch error: ${error.message}`);
        })
        .finally(() => {
            loading.style.display = 'none';
        });
    }
    
    // Generate summary when button is clicked
    summarizeBtn.addEventListener('click', async () => {
        if (!currentTranscript) {
            debug("No transcript available for summary");
            return;
        }
        
        debug("Generating summary...");
        summaryLoading.style.display = 'block';
        summaryContent.innerHTML = '<em>Analyzing transcript and generating summary...</em>';
        
        try {
            const response = await fetch('/summarize', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ 
                    transcript: currentTranscript,
                    sessionId: currentSessionId  // Include sessionId for database update
                })
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            
            debug("Summary response received");
            const data = await response.json();
            
            if (data.error) {
                if (data.error.includes('Rate limit')) {
                    summaryContent.innerHTML = `<p style="color: var(--danger);">Rate limit reached. Please wait a moment and try again.</p>`;
                    debug(`Rate limit error: ${data.error}`);
                    updateRateLimits(); // Update rate limits immediately
                } else {
                    summaryContent.innerHTML = `<p style="color: var(--danger);">Error: ${data.error}</p>`;
                    debug(`Summary error: ${data.error}`);
                }
            } else if (data.summary && data.summary.includes("error")) {
                // Format error message with red text
                summaryContent.innerHTML = `<p style="color: var(--danger);">${data.summary}</p>`;
                debug(`Summary generation had errors: ${data.summary}`);
            } else {
                // Use marked.js to render Markdown as HTML
                if (window.marked) {
                    try {
                        summaryContent.innerHTML = marked.parse(data.summary || "No summary content returned");
                        debug("Summary rendered with Markdown formatting");
                    } catch (renderError) {
                        // Fallback if markdown rendering fails
                        console.error("Error rendering markdown:", renderError);
                        summaryContent.innerHTML = data.summary || "No summary content returned";
                        debug("Summary generated but failed to render markdown");
                    }
                } else {
                    // Fallback if marked.js isn't available
                    summaryContent.innerHTML = data.summary || "No summary content returned";
                    debug("Summary generated (without markdown support)");
                }
            }
            
            // Update cost information after summary generation
            setTimeout(updateCostInfo, 500);
            
            // Update rate limits after any API call
            setTimeout(updateRateLimits, 500);
        } catch (error) {
            summaryContent.innerHTML = `<p style="color: var(--danger);">Error generating summary: ${error.message}</p>`;
            debug(`Summary fetch error: ${error.message}`);
        } finally {
            summaryLoading.style.display = 'none';
        }
    });
    
    // Cost tracker variables
    let costMinimized = false;
    const minimizeBtn = document.getElementById('minimizeBtn');
    const costContent = document.getElementById('costContent');
    
    // Toggle cost tracker minimization - FIXED EVENT HANDLER
    if (minimizeBtn) {
        minimizeBtn.addEventListener('click', function() {
            costMinimized = !costMinimized;
            if (costMinimized) {
                costContent.classList.add('minimized');
                minimizeBtn.textContent = '+';
            } else {
                costContent.classList.remove('minimized');
                minimizeBtn.textContent = '−';
            }
            debug(costMinimized ? "Cost tracker minimized" : "Cost tracker expanded");
        });
    }
    
    // Update cost information
    async function updateCostInfo() {
        if (!currentSessionId) return;
        
        try {
            const response = await fetch(`/cost/${currentSessionId}`);
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            const data = await response.json();
            
            if (data.error) {
                console.error("Error fetching cost data:", data.error);
                return;
            }
            
            // Count request types
            let transcriptionCount = 0;
            let summaryCount = 0;
            let qaCount = 0;
            
            if (data.requests) {
                data.requests.forEach(req => {
                    if (req.request_type === "transcription") transcriptionCount++;
                    else if (req.model === SUMMARY_MODEL) summaryCount++;
                    else qaCount++;
                });
            }
            
            // Update the UI
            const totalTokensEl = document.getElementById('totalTokens');
            const transcriptionRequestsEl = document.getElementById('transcriptionRequests');
            const summaryRequestsEl = document.getElementById('summaryRequests');
            const qaRequestsEl = document.getElementById('qaRequests');
            const totalCostEl = document.getElementById('totalCost');
            
            if (totalTokensEl) totalTokensEl.textContent = data.total_tokens.toLocaleString();
            if (transcriptionRequestsEl) transcriptionRequestsEl.textContent = `${transcriptionCount} requests`;
            if (summaryRequestsEl) summaryRequestsEl.textContent = `${summaryCount} requests`;
            if (qaRequestsEl) qaRequestsEl.textContent = `${qaCount} requests`;
            if (totalCostEl) totalCostEl.textContent = `$${data.total_cost.toFixed(6)}`;
            
            debug(`Updated cost info: ${data.total_tokens} tokens, $${data.total_cost.toFixed(6)}`);
        } catch (error) {
            console.error("Error updating cost information:", error);
            debug(`Error updating cost information: ${error.message}`);
        }
    }

    // Rate limit variables
    let rateLimitMinimized = false;
    const minimizeRateBtn = document.getElementById('minimizeRateBtn');
    const rateLimitContent = document.getElementById('rateLimitContent');
    
    // Toggle rate limit indicator minimization - FIXED EVENT HANDLER
    if (minimizeRateBtn) {
        minimizeRateBtn.addEventListener('click', function() {
            rateLimitMinimized = !rateLimitMinimized;
            if (rateLimitMinimized) {
                rateLimitContent.classList.add('minimized');
                minimizeRateBtn.textContent = '+';
            } else {
                rateLimitContent.classList.remove('minimized');
                minimizeRateBtn.textContent = '−';
            }
            debug(rateLimitMinimized ? "Rate limit indicator minimized" : "Rate limit indicator expanded");
        });
    }
    
    // Set constants for model names that match the backend
    const TRANSCRIPTION_MODEL = "gemini-2.0-flash";
    const SUMMARY_MODEL = "gemini-2.0-flash";
    const QnA_MODEL = "gemini-2.0-flash";

    // ...existing code for render transcript list, closing modals, etc...
    
    // Run initialization immediately
    initializeUI();
    
    // Start with rate limits update
    setTimeout(updateRateLimits, 500);
</script>
    <script>
    // ...existing code...
    
    // Update rate limit indicators
    async function updateRateLimits() {
        try {
            const response = await fetch('/rate_limits');
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            const data = await response.json();
            
            // Update transcription rate
            updateRateIndicator(
                'transcription',
                data[TRANSCRIPTION_MODEL]?.status || 'ok',
                data[TRANSCRIPTION_MODEL]?.requests_made || 0, 
                data[TRANSCRIPTION_MODEL]?.limit || 10,
                data[TRANSCRIPTION_MODEL]?.remaining_seconds || 0
            );
            
            // Update summary rate
            updateRateIndicator(
                'summary',
                data[SUMMARY_MODEL]?.status || 'ok',
                data[SUMMARY_MODEL]?.requests_made || 0, 
                data[SUMMARY_MODEL]?.limit || 10,
                data[SUMMARY_MODEL]?.remaining_seconds || 0
            );
            
            // Update QA rate
            updateRateIndicator(
                'qa',
                data[QnA_MODEL]?.status || 'ok',
                data[QnA_MODEL]?.requests_made || 0, 
                data[QnA_MODEL]?.limit || 10,
                data[QnA_MODEL]?.remaining_seconds || 0
            );
            
            // Check for cooldown messages
            let cooldownMsg = '';
            if (data[TRANSCRIPTION_MODEL]?.status === 'cooldown') {
                cooldownMsg += `Transcription: ${data[TRANSCRIPTION_MODEL].remaining_seconds}s cooldown\n`;
            }
            if (data[SUMMARY_MODEL]?.status === 'cooldown') {
                cooldownMsg += `Summary: ${data[SUMMARY_MODEL].remaining_seconds}s cooldown\n`;
            }
            if (data[QnA_MODEL]?.status === 'cooldown') {
                cooldownMsg += `Q&A: ${data[QnA_MODEL].remaining_seconds}s cooldown\n`;
            }
            
            const cooldownElement = document.getElementById('cooldownMessage');
            if (cooldownElement) {
                cooldownElement.textContent = cooldownMsg;
            }
            
            // Schedule the next update if there are active cooldowns
            if (cooldownMsg) {
                setTimeout(updateRateLimits, 1000);
            }
            
            debug("Rate limits updated");
        } catch (error) {
            console.error("Error updating rate limits:", error);
            debug(`Error updating rate limits: ${error.message}`);
        }
    }
    
    // Helper function for updating a single rate indicator
    function updateRateIndicator(type, status, requestsMade, limit, remainingSeconds) {
        const light = document.getElementById(`${type}Light`);
        const bar = document.getElementById(`${type}Bar`);
        const limitText = document.getElementById(`${type}Limit`);
        
        if (!light || !bar || !limitText) return; // Skip if elements don't exist
        
        // Update limit text
        limitText.textContent = `${limit}/min`;
        
        if (status === 'cooldown') {
            // Red status (in cooldown)
            light.className = 'rate-status-light status-red';
            bar.style.width = '100%';
            bar.style.backgroundColor = 'var(--danger)';
        } else {
            // Calculate percentage
            const percentage = (requestsMade / limit) * 100;
            bar.style.width = `${percentage}%`;
            
            if (percentage >= 80) {
                // Yellow status (warning)
                light.className = 'rate-status-light status-yellow';
                bar.style.backgroundColor = 'var(--warning)';
            } else {
                // Green status (good)
                light.className = 'rate-status-light status-green';
                bar.style.backgroundColor = 'var(--primary)';
            }
        }
    }
    
    // Send a question function
    async function sendQuestion() {
        const question = questionInput.value.trim();
        if (!question) {
            debug("Empty question - not sending");
            return;
        }
        
        if (!currentSessionId) {
            debug("No session ID available - cannot send question");
            addMessage("Please transcribe an audio file first before asking questions.", "ai");
            return;
        }
        
        debug(`Sending question: ${question}`);
        
        // Add user message to chat
        addMessage(question, 'user');
        questionInput.value = '';
        
        // Add a temporary loading message
        const loadingMsgId = Date.now();
        addLoadingMessage(loadingMsgId);
        
        try {
            const response = await fetch('/ask_question', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    question: question,
                    sessionId: currentSessionId,
                    transcript: currentTranscript // Fallback if session storage fails
                })
            });
            
            // Remove the loading message
            removeLoadingMessage(loadingMsgId);
            
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            
            debug("Question response received");
            const data = await response.json();
            
            if (data.error) {
                if (data.error.includes('Rate limit')) {
                    addMessage(`Rate limit reached. Please wait a moment and try again.`, 'ai');
                    debug(`Rate limit error: ${data.error}`);
                    updateRateLimits(); // Update rate limits immediately
                } else {
                    addMessage(`Error: ${data.error}`, 'ai');
                    debug(`Question error: ${data.error}`);
                }
            } else if (data.answer && data.answer.includes("Error")) {
                addMessage(`${data.answer}`, 'ai');
                debug(`Question answering had errors: ${data.answer}`);
            } else {
                addMessage(data.answer || "No answer received", 'ai');
                debug("Question answered successfully");
            }
            
            // Update cost information after question answering
            setTimeout(updateCostInfo, 500);
            
            // Update rate limits after any API call
            setTimeout(updateRateLimits, 500);
        } catch (error) {
            // Remove the loading message
            removeLoadingMessage(loadingMsgId);
            
            addMessage(`Error: ${error.message}`, 'ai');
            debug(`Question fetch error: ${error.message}`);
        }
    }
    
    // Add a message to the chat interface
    function addMessage(text, sender) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${sender}-message`;
        messageDiv.textContent = text;
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        debug(`Added ${sender} message to chat`);
    }
    
    // Add a loading message with typing animation
    function addLoadingMessage(id) {
        const loadingDiv = document.createElement('div');
        loadingDiv.className = 'message ai-message';
        loadingDiv.id = `loading-msg-${id}`;
        loadingDiv.innerHTML = '<div class="dot-pulse"></div>';
        chatMessages.appendChild(loadingDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    // Remove a loading message
    function removeLoadingMessage(id) {
        const loadingMsg = document.getElementById(`loading-msg-${id}`);
        if (loadingMsg) {
            loadingMsg.remove();
        }
    }

    // ...existing code...
    
    // Hook up the question input and button
    if (sendQuestionBtn) {
        sendQuestionBtn.addEventListener('click', sendQuestion);
    }
    
    if (questionInput) {
        questionInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendQuestion();
        });
    }
    
    // New code for transcript collapsing (copy button functionality)
    const copyTranscriptBtn = document.getElementById('copyTranscriptBtn');
    const copySummaryBtn = document.getElementById('copySummaryBtn');
    const collapseTranscriptBtn = document.getElementById('collapseTranscriptBtn');
        
    // Toggle transcript collapse
    let transcriptCollapsed = false;
    if (collapseTranscriptBtn) {
        collapseTranscriptBtn.addEventListener('click', () => {
            const transcriptSection = document.getElementById('transcriptSection');
            if (!transcriptSection) return;
            
            transcriptCollapsed = !transcriptCollapsed;
            
            if (transcriptCollapsed) {
                transcriptSection.classList.add('collapsed');
                collapseTranscriptBtn.querySelector('i').classList.add('rotate-icon');
            } else {
                transcriptSection.classList.remove('collapsed');
                collapseTranscriptBtn.querySelector('i').classList.remove('rotate-icon');
            }
        });
    }
    
    // Copy function for clipboard
    async function copyToClipboard(text, tooltipElement) {
        try {
            if (navigator.clipboard) {
                await navigator.clipboard.writeText(text);
                // Show tooltip feedback
                tooltipElement.classList.add('show');
                setTimeout(() => {
                    tooltipElement.classList.remove('show');
                }, 2000);
            } else {
                // Fallback
                const tempTextArea = document.createElement('textarea');
                tempTextArea.value = text;
                document.body.appendChild(tempTextArea);
                tempTextArea.select();
                document.execCommand('copy');
                document.body.removeChild(tempTextArea);
                
                tooltipElement.classList.add('show');
                setTimeout(() => {
                    tooltipElement.classList.remove('show');
                }, 2000);
            }
        } catch (err) {
            console.error('Failed to copy: ', err);
        }
    }
    
    // Copy transcript button
    if (copyTranscriptBtn) {
        copyTranscriptBtn.addEventListener('click', () => {
            if (!transcript) return;
            
            const transcriptText = transcript.textContent || '';
            const tooltipElement = copyTranscriptBtn.querySelector('.tooltip-text');
            copyToClipboard(transcriptText, tooltipElement);
        });
    }
    
    // Copy summary button
    if (copySummaryBtn) {
        copySummaryBtn.addEventListener('click', () => {
            if (!summaryContent) return;
            
            const summaryText = summaryContent.textContent || '';
            const tooltipElement = copySummaryBtn.querySelector('.tooltip-text');
            copyToClipboard(summaryText, tooltipElement);
        });
    }
</script>
    <script>
    // ...existing code...
    
    // Function to render the transcript list in the sidebar
    function renderTranscriptList() {
        if (!transcriptList) return;
        
        if (!userTranscripts || userTranscripts.length === 0) {
            transcriptList.innerHTML = `
                <li class="transcript-list-item">
                    <div class="transcript-list-item-icon">
                        <i class="fas fa-info-circle"></i>
                    </div>
                    <div class="transcript-list-item-text">No transcripts yet</div>
                </li>
            `;
            return;
        }
        
        debug(`Rendering ${userTranscripts.length} transcripts in sidebar`);
        
        // Sort transcripts by created_at date (newest first)
        userTranscripts.sort((a, b) => {
            return new Date(b.created_at) - new Date(a.created_at);
        });
        
        let html = '';
        userTranscripts.forEach(t => {
            const isActive = t.transcript_id === currentTranscriptId;
            const title = t.title || 'Untitled Transcript';
            
            // Use data attributes instead of inline onclick to avoid scope issues
            html += `
                <li class="transcript-list-item ${isActive ? 'active' : ''}" data-id="${t.transcript_id}">
                    <div class="transcript-list-item-icon">
                        <i class="fas fa-file-alt"></i>
                    </div>
                    <div class="transcript-list-item-text">${title}</div>
                    <div class="transcript-list-item-actions">
                        <button class="action-btn-sm edit-btn" data-id="${t.transcript_id}" data-title="${title}">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="action-btn-sm delete-btn" data-id="${t.transcript_id}" data-title="${title}">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </li>
            `;
        });
        
        transcriptList.innerHTML = html;
        
        // Add event listeners to each item after they're added to the DOM
        document.querySelectorAll('.transcript-list-item').forEach(item => {
            item.addEventListener('click', function() {
                const id = this.getAttribute('data-id');
                if (id) {
                    debug(`Transcript item clicked: ${id}`);
                    window.loadTranscript(id);
                }
            });
        });
        
        // Add event listeners for edit and delete buttons
        document.querySelectorAll('.edit-btn').forEach(btn => {
            btn.addEventListener('click', function(event) {
                event.stopPropagation(); // Prevent triggering the parent click
                const id = this.getAttribute('data-id');
                const title = this.getAttribute('data-title');
                if (id) openRenameModal(id, title);
            });
        });
        
        document.querySelectorAll('.delete-btn').forEach(btn => {
            btn.addEventListener('click', function(event) {
                event.stopPropagation(); // Prevent triggering the parent click
                const id = this.getAttribute('data-id');
                const title = this.getAttribute('data-title');
                if (id) openDeleteModal(id, title);
            });
        });
    }

    // Load user transcripts from the server with improved error handling
    function loadUserTranscripts() {
        debug("Fetching user transcripts...");
        
        fetch('/api/transcripts')
            .then(response => {
                debug(`Received response with status: ${response.status}`);
                if (!response.ok) {
                    throw new Error(`Failed to load transcripts: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                debug(`Received ${data.transcripts ? data.transcripts.length : 0} transcripts`);
                userTranscripts = data.transcripts || [];
                renderTranscriptList();
            })
            .catch(error => {
                debug(`Error loading transcripts: ${error.message}`);
                if (transcriptList) {
                    transcriptList.innerHTML = `
                        <li class="transcript-list-item">
                            <div class="transcript-list-item-icon">
                                <i class="fas fa-exclamation-circle" style="color: var(--danger);"></i>
                            </div>
                            <div class="transcript-list-item-text">Error loading transcripts: ${error.message}</div>
                        </li>
                    `;
                }
            });
    }

    // Make loadTranscript available to the window object for global access
    window.loadTranscript = function(transcriptId) {
        if (!transcriptId) return;
        
        debug(`Loading transcript: ${transcriptId}`);
        
        fetch(`/api/transcript/${transcriptId}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Failed to load transcript: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                // Update global variables
                currentSessionId = data.sessionId || data.transcript_id;
                currentTranscriptId = data.transcript_id;
                currentTranscript = data.transcript;
                
                // Format the transcript with speaker highlighting
                const formattedText = data.transcript.replace(
                    /(Speaker \d+|[A-Za-z]+ [A-Za-z]+):/g, 
                    '<span class="speaker">$1:</span>'
                );
                transcript.innerHTML = formattedText || "No transcript content";
                
                // Update title
                transcriptTitle.value = data.title || 'Untitled Transcript';
                transcriptTitle.dataset.originalValue = data.title || 'Untitled Transcript';
                
                // Update summary if available
                if (data.summary && data.summary.trim()) {
                    // Use marked.js to render Markdown as HTML
                    if (window.marked) {
                        try {
                            summaryContent.innerHTML = marked.parse(data.summary);
                        } catch (error) {
                            summaryContent.innerHTML = data.summary;
                        }
                    } else {
                        summaryContent.innerHTML = data.summary;
                    }
                } else {
                    summaryContent.innerHTML = '<em>No summary available. Click "Generate Summary" to create one.</em>';
                }
                
                // If there's an audio URL, load it into the player
                if (data.audioUrl) {
                    audioPlayer.src = data.audioUrl;
                    audioPlayerContainer.style.display = 'block';
                } else {
                    audioPlayerContainer.style.display = 'none';
                }
                
                // Update UI state
                setActiveTranscript(transcriptId);
                
                // Reset any error messages
                debug("Transcript loaded successfully");
            })
            .catch(error => {
                debug(`Error loading transcript: ${error.message}`);
                transcript.innerHTML = `<p style="color: var(--danger);">Error loading transcript: ${error.message}</p>`;
            });
    };


</script>
    <script>

    
    // Make sure the setActiveTranscript function is defined BEFORE loadTranscript
    function setActiveTranscript(transcriptId) {
        currentTranscriptId = transcriptId;
        
        // Update active item in the list
        document.querySelectorAll('.transcript-list-item').forEach(item => {
            if (item.dataset && item.dataset.id === transcriptId) {
                item.classList.add('active');
                activeTranscriptItem = item;
            } else {
                item.classList.remove('active');
            }
        });
    }

    // Make loadTranscript available to the window object for global access
    window.loadTranscript = function(transcriptId) {
        if (!transcriptId) return;
        
        debug(`Loading transcript: ${transcriptId}`);
        
        fetch(`/api/transcript/${transcriptId}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Failed to load transcript: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                // Update global variables
                currentSessionId = data.sessionId || data.transcript_id;
                currentTranscriptId = data.transcript_id;
                currentTranscript = data.transcript;
                
                // Format the transcript with speaker highlighting
                const formattedText = data.transcript.replace(
                    /(Speaker \d+|[A-Za-z]+ [A-Za-z]+):/g, 
                    '<span class="speaker">$1:</span>'
                );
                transcript.innerHTML = formattedText || "No transcript content";
                
                // Update title
                transcriptTitle.value = data.title || 'Untitled Transcript';
                transcriptTitle.dataset.originalValue = data.title || 'Untitled Transcript';
                
                // Update summary if available
                if (data.summary && data.summary.trim()) {
                    // Use marked.js to render Markdown as HTML
                    if (window.marked) {
                        try {
                            summaryContent.innerHTML = marked.parse(data.summary);
                        } catch (error) {
                            summaryContent.innerHTML = data.summary;
                        }
                    } else {
                        summaryContent.innerHTML = data.summary;
                    }
                } else {
                    summaryContent.innerHTML = '<em>No summary available. Click "Generate Summary" to create one.</em>';
                }
                
                // If there's an audio URL, load it into the player
                if (data.audioUrl) {
                    audioPlayer.src = data.audioUrl;
                    audioPlayerContainer.style.display = 'block';
                } else {
                    audioPlayerContainer.style.display = 'none';
                }
                
                // Update UI state - this function is now defined above
                setActiveTranscript(transcriptId);
                
                // Reset any error messages
                debug("Transcript loaded successfully");
            })
            .catch(error => {
                debug(`Error loading transcript: ${error.message}`);
                transcript.innerHTML = `<p style="color: var(--danger);">Error loading transcript: ${error.message}</p>`;
            });
    };


</script>
    <script>
    // ...existing code...

    // Clear the transcript and reset UI - fixed to properly handle New Transcription button
    function clearTranscript() {
        // Reset all the state variables
        currentTranscriptId = null;
        currentTranscript = null;
        currentSessionId = null;
        
        // Reset UI elements
        transcript.innerHTML = '<em>No transcript yet. Upload a file to begin.</em>';
        summaryContent.innerHTML = '<em>Generate a summary after transcribing your audio.</em>';
        
        // Reset the title
        transcriptTitle.value = 'New Transcription';
        transcriptTitle.dataset.originalValue = 'New Transcription';
        
        // Clear audio player
        audioPlayer.src = '';
        audioPlayerContainer.style.display = 'none';
        
        // Reset chat
        chatMessages.innerHTML = '<div class="message ai-message">Ask me questions about the transcript!</div>';
        
        // Reset active item in sidebar
        setActiveTranscript(null);
        
        // Make sure we remove any previous audio file selection
        if (fileInput) {
            fileInput.value = '';
        }
        
        // Reset any collapsed sections
        const transcriptSection = document.getElementById('transcriptSection');
        if (transcriptSection && transcriptSection.classList.contains('collapsed')) {
            transcriptSection.classList.remove('collapsed');
            const collapseBtn = document.getElementById('collapseTranscriptBtn');
            if (collapseBtn && collapseBtn.querySelector('i')) {
                collapseBtn.querySelector('i').classList.remove('rotate-icon');
            }
            transcriptCollapsed = false;
        }
        
        // Show the upload area
        if (uploadArea) {
            uploadArea.style.display = 'block';
        }
        
        debug("Cleared transcript and reset UI for new transcription");
    }
    
    // Make sure setActiveTranscript properly handles null case
    function setActiveTranscript(transcriptId) {
        currentTranscriptId = transcriptId;
        
        // Update active item in the list - handle null case properly
        document.querySelectorAll('.transcript-list-item').forEach(item => {
            // Always remove the active class first
            item.classList.remove('active');
            
            // Only add it back if we have a matching ID and it's not null
            if (transcriptId && item.dataset && item.dataset.id === transcriptId) {
                item.classList.add('active');
                activeTranscriptItem = item;
            }
        });
        
        // If setting to null (new transcription), make sure we don't have an activeTranscriptItem
        if (!transcriptId) {
            activeTranscriptItem = null;
        }
    }

    // ...existing code...
</script>
</body>
</html>
